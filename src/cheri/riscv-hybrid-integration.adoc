[#section_cheri_hybrid_ext]
== "{cheri_default_ext_name}" Extension for CHERI {cheri_int_mode_name}

ifdef::cheri_standalone_spec[]
WARNING: This chapter will appear in the unpriv spec somewhere after the Zicsr chapter (since it depends on Zicsr).
endif::[]

{cheri_default_ext_name} is an optional extension to {cheri_base_ext_name}.
Implementations that support {cheri_base_ext_name} and {cheri_default_ext_name}
define a variant of the CHERI ISA that is fully binary compatible with
existing RISC-V code.

Key features in {cheri_default_ext_name} include a definition of a CHERI execution mode, a new
unprivileged register, additional instructions and extensions to some existing
CSRs enabling CHERI features. The remainder of this section describes
these features in detail as well as their integration with the primary base
integer variants of the RISC-V ISA (RV32I and RV64I).

[#section-cheri-execution-mode,reftext="CHERI Execution Mode"]
=== CHERI Execution Mode

{cheri_default_ext_name} adds the ability to dynamically change CHERI execution modes to ensure backwards
compatibility with the base RISC-V ISA while saving instruction encoding space.
As noted in <<sec_cheri_cap_mode_int_mode>>, there are two execution modes: {cheri_cap_mode_name} and {cheri_int_mode_name}.
The current CHERI execution mode is given by the <<m_bit>> of <<pcc>> that
is encoded as described in xref:m_bit[xrefstyle=short].

Additionally, {cheri_default_ext_name} adds a new unprivileged CSR: the default data capability, <<ddc>>, that is
used to authorize all data memory accesses when in
{cheri_int_mode_name}.

The CHERI execution mode impacts the instruction set in the following ways:

* The authorizing capability used to execute memory access instructions.
In {cheri_int_mode_name}, <<ddc>> is implicitly used. In {cheri_cap_mode_name}, the authorizing
capability is supplied as an explicit *c* operand register to the instruction.
* The set of instructions that is available for execution. Some instructions
are available in {cheri_int_mode_name} but not {cheri_cap_mode_name} and vice-versa (see
xref:app_cheri_instructions[xrefstyle=short]).

NOTE: The implication is that the CHERI execution mode is always {cheri_cap_mode_name} on
implementations that support {cheri_base_ext_name}, but not
{cheri_default_ext_name}.

The CHERI execution mode is effectively an extension to some RISC-V instruction
encodings. For example, the encoding of an instruction like <<LW>> remains
unchanged, but the mode indicates whether the capability authorizing the load
is the register operand `cs1` ({cheri_cap_mode_name}). The mode is shown in the assembly
syntax.

The CHERI execution mode is key in providing backwards compatibility with the
base RISC-V ISA. RISC-V software is able to execute unchanged in
implementations supporting both {cheri_base_ext_name} and
{cheri_default_ext_name} provided that the <<infinite-cap>> capability is installed in <<ddc>> and <<pcc>>
(with <<m_bit,M={INT_MODE_VALUE}>>, i.e. in {cheri_int_mode_name}).
Setting both registers to <<infinite-cap>> ensures that:

* All permissions are granted
* The bounds authorize accesses to the entire address space i.e base is 0 and
top is 2^MXLEN^

[#m_bit,reftext="M-bit"]
==== CHERI Execution Mode Encoding

{cheri_default_ext_name} adds a new CHERI execution Mode field (M) to
the capability format, which is only valid for code capabilities, i.e.
when the <<x_perm>> is set.
The exact location of the M-bit in the capability format for XLEN=32 and XLEN=64 is described in <<app_cap_description>>.

* Mode (M)={CAP_MODE_VALUE} indicates {cheri_cap_mode_name}.
* Mode (M)={INT_MODE_VALUE} indicates {cheri_int_mode_name}.

The current CHERI execution mode is given by the <<m_bit>> of the <<pcc>> and the <<section_cheri_disable,CHERI register and instruction access settings>> as follows:

* The Mode is {cheri_cap_mode_name} when the <<m_bit>> of the <<pcc>> is {CAP_MODE_VALUE}, *and* <<section_cheri_disable,CHERI register and instruction access is enabled>> for the current privilege.
* Otherwise the Mode is {cheri_int_mode_name}.

When the <<m_bit>> can be set, the rules defined by <<ACPERM>> must be followed.

[#m_bit_observe,reftext="Observing the CHERI Execution Mode"]
==== Observing the CHERI Execution Mode

The effective CHERI execution mode is given by the values of some CSRs and the
<<m_bit>> from the <<pcc>>.
The following code sequence demonstrate how a program can observe the current, effective CHERI execution mode.
It will write {CAP_MODE_VALUE} for {cheri_cap_mode_name} and {INT_MODE_VALUE} for {cheri_int_mode_name} to `x1`:

[source]
----
auipc c1, 0
gctag x1, c1
----

[#section_hybrid_ext_instructions]
=== {cheri_default_ext_name} Instructions

{cheri_default_ext_name} introduces a new instructions to switch CHERI execution modes.
Additionally, {cheri_default_ext_name} makes all instructions defined by {cheri_default_ext_name} available.

* A new <<SCMODE>> instruction allows setting a capability's CHERI execution
mode to the indicated value. The output is written to an unprivileged *c*
register, not <<pcc>>.

* A new <<GCMODE>> instruction allows decoding the CHERI execution mode from an
arbitrary capability held in an *x* register. The output is written to an
unprivileged *x* register.

* CHERI execution mode switch instructions, <<MODESW_CAP>> and
<<MODESW_INT>>, allow software
to change the hart's current <<m_bit>> in <<pcc>>. If the current mode in the
<<pcc>> is {cheri_int_mode_name}, then the mode after executing <<MODESW_CAP>> is {cheri_cap_mode_name}
and similarly for <<MODESW_INT>> when in {cheri_cap_mode_name}. This instruction effectively writes the CHERI execution mode
<<m_bit>> of the capability currently installed in the <<pcc>>.

include::insns/scmode_32bit.adoc[]

include::insns/gcmode_32bit.adoc[]

include::insns/modesw_32bit.adoc[]

==== Capability Load and Store Instructions

The load and store capability instructions introduced in {cheri_base_ext_name} change behavior depending on the
CHERI execution mode although the instruction's encoding remains unchanged.

==== <<LC>>

The load capability instruction is <<LC>>. When the CHERI execution mode is
{cheri_cap_mode_name}; the instruction behaves as described in
xref:section_cap_instructions[xrefstyle=short].
In {cheri_int_mode_name}, the capability authorizing the memory access
is <<ddc>>, so the effective address is obtained by adding the *x* register to
the sign-extended offset.

==== <<SC>>

The store capability instruction is <<SC>>. When the CHERI execution mode is
{cheri_cap_mode_name}; the instruction behaves as described in
xref:section_cap_instructions[xrefstyle=short].
In {cheri_int_mode_name}, the capability authorizing the memory access
is <<ddc>>, so the effective address is obtained by adding the *x* register to
the sign-extended offset.

=== Existing RISC-V Instructions

The CHERI execution mode introduced in {cheri_default_ext_name} affects the
behavior of instructions that have at least one memory address operand. When
in {cheri_cap_mode_name}, the address input or output operands may include *c* registers.
When in {cheri_int_mode_name}, the address input or output operands are *x/f/v* registers;
the validity tag and metadata of that register are implicitly set to 0.

==== Control Transfer Instructions

The unconditional jump instructions change behavior depending on the CHERI
execution mode although the instruction's encoding remains unchanged.

The jump and link instruction <<JAL_CHERI>> when the CHERI execution mode is
{cheri_cap_mode_name}; behaves as described in
xref:section_existing_riscv_insns[xrefstyle=short].
When the mode is {cheri_int_mode_name}. In this case, the address of the instruction
following the jump (*pc* + 4) is written to an *x* register; that register's
tag and capability metadata are zeroed.

The jump and link register instruction is <<JALR_CHERI>> when the CHERI execution mode
is {cheri_cap_mode_name}; behaves as described in
xref:section_existing_riscv_insns[xrefstyle=short].
When the mode is {cheri_int_mode_name}. In this case, the target address is obtained by adding
the sign-extended 12-bit immediate to the *x* register operand, then setting
the least significant bit of the result to zero. The target address is then
written to the <<pcc>> address and a representability check is performed. The
address of the instruction following the jump (*pc* + 4) is written to an *x*
register; that register's tag and capability metadata are zeroed.

{cheri_default_ext_name} allows changing the current CHERI execution mode when
executing <<JALR_CHERI>> from {cheri_cap_mode_name}.

<<JAL_CHERI>> and <<JALR_CHERI>> cause CHERI exceptions when a minimum sized instruction
at the target address is not within the bounds of the <<pcc>>. An
instruction address misaligned exception is raised when the target address is
misaligned.

==== Conditional Branches

The behavior is as shown in xref:condbr-purecap[xrefstyle=short].

==== Load and Store Instructions

Load and store instructions change behavior depending on the CHERI execution
mode although the instruction's encoding remains unchanged.

Loads and stores behave as described in
xref:section_existing_riscv_insns[xrefstyle=short] when in {cheri_cap_mode_name}.
In {cheri_int_mode_name}, the instructions behave as described in
the RISC-V base ISA and rely on *x* operands
only. The capability authorizing the memory access is <<ddc>> and the memory
address is given by sign-extending the 12-bit immediate offset and adding it to
the base address in the *x* register operand.

The exception cases remain as described in
xref:section_existing_riscv_insns[xrefstyle=short] regardless of the CHERI
execution mode.

[#zicsr-section-default]
==== CSR Instructions

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* CSpecialRW is removed. Its role is assumed by
<<CSRRW>>.
endif::[]

{cheri_default_ext_name} adds the concept of CSRs which contain a capability
where the address field is visible in {cheri_int_mode_name} (e.g. <<mtvec>>) and the full
capability is visible in {cheri_cap_mode_name} through a different name (e.g.
<<mtvecc>>). These are referred to as _extended CSRs_. Also,
{cheri_default_ext_name} adds the new capability CSRs listed in
xref:default-csrnames-added[xrefstyle=short].

Extended CSRs have only one address; the access width is determined by the
execution mode.

When <<CSRRW>> is executed on an extended CSR in {cheri_int_mode_name}:

* The register operand is an *x* register.
* Only XLEN bits from the *x* source are written to the capability address
field.
    ** The validity tag and metadata are updated as specified in <<extended_CSR_writing>>.
* Only XLEN bits are read from the capability address field, which are extended
to MXLEN bits according to cite:[riscv-priv-spec] _(3.1.6.2. Base ISA Control in
mstatus Register)_ and are then written to the destination *x* register.

When <<CSRRW>> is executed on an extended CSR in {cheri_cap_mode_name}, or
on a new capability CSR regardless of the CHERI execution mode:

* The register operand is a *c* register.
* The full capability in the *c* register source is written to the CSR.
** The capability may require modification before the final written value is
determined (see <<extended_CSR_writing>>).
* The full capability is written to destination *c* register.

When an extended CSR or a new capability CSR is used with another CSR
instruction (<<CSRRWI>>, <<CSRRC>>, <<CSRRCI>>, <<CSRRS>>, <<CSRRSI>>):

* The final address is calculated according to the standard RISC-V CSR rules
(set bits, clear bits etc).
* The final address is updated as specified in <<extended_CSR_writing>> for an
XLEN write.
* When accessing an extended CSR:
    ** In {cheri_int_mode_name}, XLEN bits are read from the capability address
field and written to an output *x* register.
    ** In {cheri_cap_mode_name}, CLEN bits are read from the CSR and written to
an output *c* register.
* When accessing a new capability CSR:
    ** CLEN bits are read from the CSR and written to an output *c* register.

All CSR instructions cause CHERI exceptions if the <<pcc>> does not grant
<<asr_perm>> and the CSR accessed is not user-mode accessible.

=== Added Capability CSRs

{cheri_default_ext_name} adds the capability CSRs shown in
xref:default-csrnames-added[xrefstyle=short].

[[default-csrnames-added]]
.Capability CSRs added in {cheri_default_ext_name}
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
include::generated/csr_added_hybrid_table_body.adoc[]
|===

[#ddc,reftext="ddc"]
==== Default Data Capability CSR (ddc)

<<ddc>> is a capability CSR. The address is shown in
xref:default-csrnames-added[xrefstyle=short].

<<ddc>> is a read-write, user mode accessible capability CSR implicitly used as an
operand to authorize all data memory accesses when the current CHERI mode is
{cheri_int_mode_name}. This CSR must be readable in any implementation. Its reset value
is the <<infinite-cap>> capability.

{REQUIRE_CRE_CSR}

NOTE: CRE is not required for the implicit access required by checking memory accesses against <<ddc>>

{REQUIRE_HYBRID_CSR}

As shown in xref:CSR_exevectors[xrefstyle=short], <<ddc>> is a data pointer,
so it does not need to be able to hold all possible invalid addresses (see <<section_invalid_addr_conv>>).

.Unprivileged default data capability register
include::img/ddcreg.edn[]
