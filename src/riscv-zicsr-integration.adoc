=== Integrating Zicsr with {cheri_base_ext_name}

{cheri_base_ext_name} requires that RISC-V CSRs intended to hold addresses,
are now able to hold capabilities. Therefore, such registers are
extended to CLEN+1 bits in {cheri_base_ext_name} and a `c` suffix is added (e.g. <<mtvec>> is extended to <<mtvecc>>).

Reading or writing any part of a capability CSR may cause
side effects. For example, the CSR's tag bit may be cleared if a new address
is outside the <<section_cap_representable_check>> of a CSR capability being written.

This section describes how the CSR instructions operate on these CSRs in
{cheri_base_ext_name}.

The capability CSRs are summarized in xref:clen_csr_summary[xrefstyle=short].

[#zicsr-section-purecap]
==== CSR Instructions

ifdef::cheri_v9_annotations[]
NOTE: *CHERI v9 Note:* CSpecialRW is removed. Its role is assumed by
<<CSRRW>>.
endif::[]

All CSR instructions atomically read-modify-write a single CSR. If the CSR
accessed is of capability size then the
capability's tag, metadata and address are all accessed atomically.

When the <<CSRRW>> instruction is accessing a capability width CSR, then the source
and destination operands are *c* registers and it atomically swaps the values in the
whole CSR with the CLEN width register operand.

There are special rules for updating specific capability CSRs as shown in <<extended_CSR_writing>>.

When <<CSRRS>> and <<CSRRC>> instructions are accessing a capability width CSR,
such as <<mtvecc>>, then the destination operand is a *c* register and the
source operand is an *x* register. Therefore, the instructions atomically read
CLEN bits from the CSR, calculate the final address using standard RISC-V
behavior (set bits, clear bits, etc.), and that final address is written to the
CSR capability's address field. The update typically uses the semantics of a
<<SCADDR>> instruction which clears the tag if the capability is sealed, or
if the updated address is not representable. <<extended_CSR_writing>> shows the
exact action taken for each capability width CSR.

The <<CSRRWI>>, <<CSRRSI>> and <<CSRRCI>> variants are similar to <<CSRRW>>,
<<CSRRS>>, and <<CSRRC>> respectively, when accessing a capability width CSR
except that they update the capability's address only using an XLEN-bit value
obtained by zero-extending a 5-bit unsigned immediate field.

All CSR instructions cause CHERI exceptions if the <<pcc>> does not grant
<<asr_perm>> and the CSR accessed is privileged.
