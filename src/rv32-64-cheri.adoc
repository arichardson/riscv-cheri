[[rv32ch]]
== RV32CH and RV64CH Base Capability Instruction Sets, Version 1.0
This chapter describes the RV32CH and RV64CH base capability
instruction sets, that extend the RV32I and RV64I integer instruction
sets with capability-based addressing.

=== CHERI capabilities

{cheri_base_ext_name} introduces a new data type, the _capability_, generally used for architectural pointers.
Capability registers extend existing XLEN-bit integer registers to `2*XLEN+1` (hereafter referred to as CLEN) bit structures, containing all the information required to identify and authorize access to a region of memory.

.CHERI Capability structure
[#cap_structure]
[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback" :font-size 25}])
(def row-height 80)
(def row-header-fn nil)
(def boxes-per-row 32)
(draw-column-headers {:height 50 :font-size 18 :labels (reverse ["0" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "XLEN-1" "" ""])})

(draw-box "V"    {:span 1})
(draw-box "" {:span 1 :borders {}})
(draw-box "Metadata (bounds, permissions, etc.)"    {:span 30})
(draw-box "" {:span 2 :borders {}})
(draw-box "Address"     {:span 30})
(draw-box "" {:span 2 :borders {}})
(draw-box "XLEN" {:span 30 :borders {}})
----

CHERI capabilities consist of:

* An XLEN-bit address, describing where the capability currently points.
* XLEN bits of metadata:
** Bounds: a _base_ and a _top_ address, describing the range of addresses the capability can be used to access.
** Permissions (read, write, execute, ...) describing the kinds of operations the capability can be used for.
** Sealing information: a capability can be _sealed_, restricting it to only be used or modified in particular ways.
* A one-bit integrity tag (the `V` field in <<cap_structure>>): this is maintained by hardware and cannot be directly modified by software.
 It indicates whether the capability is valid.
 An initial <<infinite-cap>> capability with access to all of memory (with all permissions) is provided in system registers on reset: all valid capabilities are derived from it.
 This is the only way to obtain a valid capability: no software, even machine mode, can _forge_ a capability.

The exact bitwise layout of capabilities as well as the precise encoding of each field for XLEN=32 and XLEN=64 is described in <<section_cap_description>>.

=== Added State

The following state is added by {cheri_base_ext_name}:

* Metadata within architectural registers: XLEN-wide <<gprs,general purpose integer registers>> (e.g. `sp`, `a0`) are all extended with another XLEN bits of capability metadata plus a validity bit.
When referring to the extended register, the `x` prefix is replaced with a `c`: i.e. the capability extended version of `x0` becomes `c0`.
The existing integer register names refer to the address part of the capability.
For the ABI register names the a `c` prefix is added, i.e. `csp`, `ca0`.
The zero register is extended with zero metadata and a cleared tag: this is called the <<null-cap>> capability.
As well as general purpose registers, system registers that store addresses are extended to contain capabilities.
In the base {cheri_base_ext_name}, the only such register is the program counter `pc` that is extended to the program counter capability (<<pcc>>). Extending `pc` ensures that the range of branches and jumps for currently executing code can be restricted.
Additionally, CSRs that hold pointers are extended to capability, but since no CSRs are defined in the RV32I/RV64I base instruction set, the individual chapters that define new CSRs state whether they are extended to CLEN bits.

.CHERI Capability registers extending existing integer registers in {cheri_base_ext_name}
[#base_cap_registers]
[bytefield]
----
(defattrs :plain [:plain {:font-family "M+ 1p Fallback" :font-size 25}])
(def row-height 40)
(def row-header-fn nil)
(def boxes-per-row 20)
(draw-column-headers {:height 30 :font-size 18 :labels (concat ["" "2*XLEN (CLEN-1)"] (vec (repeat 8 "")) ["XLEN"] (vec (repeat 8 "")) ["0"])})

(draw-box "c0" [:box-first {:span 10}]) (draw-box "x0" [:box-last {:span 10 }])
(draw-box "c1" [:box-first {:span 10}]) (draw-box "x1" [:box-last {:span 10 }])
(draw-gap "c2-c30 (extending x2-x30)")
(draw-box "c31" [:box-first {:span 10}]) (draw-box "x31" [:box-last {:span 10 }])
(draw-box "pcc" [:box-first {:span 10}]) (draw-box "pc" [:box-last {:span 10 }])
----

* Tags in registers, caches, and memory:

** Every register has a one-bit tag, indicating whether the capability in the register is valid to be dereferenced.
 This tag is cleared whenever an invalid capability operation is performed. Such invalid operations include e.g. writing only the integer portion of the register or attempting to increase bounds or permissions.

** The tags are also tracked through the memory subsystem: every aligned CLEN-bits wide region has a non-addressable one-bit tag, which the hardware manages atomically with the data.
The tag is cleared if the memory region is ever written using an operation other than a store of a full capability register.
Any caches must preserve this abstraction.

=== Added Instructions

{cheri_base_ext_name} adds new instructions to interact with the extended registers.
These added instructions can be split into the following categories:

* Capability manipulations (e.g. <<CADD>>, <<SCBNDS>>): for security, capabilities can only be modified in restricted ways.
Special instructions are provided to perform these allowed operations, for example _shrinking_ the bounds or _reducing_ the permissions.
Any attempt to manipulate capabilities without using the instructions clears the tag, rendering them unusable for accessing memory.

* Capability inspection (e.g. <<GCBASE>>, <<GCPERM>>): capability fields (for example the _bounds_ describing what addresses the capability gives access to) are stored compressed in registers and memory.
These instructions give convenient access to allow software to query them.

* Memory access instructions (e.g. <<LC>>, <<SC>>): capabilities must be read from and written to memory atomically along with their tag.
Instructions are added to perform these wider accesses, allowing capability flow between the memory and the register file.

// TODO: add the base instructions here

=== Existing Instructions

Existing RISC-V instructions are largely unmodified.
However, instructions that access memory, as well as branches and jumps are modified to check against the full capability from the address register (e.g. `lw t0, 16(csp)`).
In some cases, they are also changed to return a full capability value, e.g. <<AUIPC>> will return the full <<pcc>> including the metadata.
For the full list of instructions that change behavior with {cheri_base_ext_name}, see <<app_cheri_modified_instrs>>.

=== Capability checks

Every memory access performed by a CHERI core must be authorized by a capability.
The authorizing capability is either named explicitly (the base register of a load/store operation) or implicitly (when executing a branch, <<pcc>> is used for authorization).
For example, `lw t0, 16(csp)` loads a word from memory, getting the address, bounds, and permissions from the `csp` register.

Instruction fetch is also authorized by a capability: the program counter capability (<<pcc>>) which extends PC.
This allows code fetch to be bounded, preventing a wide range of attacks that subvert control flow with integer data.

With {cheri_base_ext_name} instruction fetches, jumps, and memory accesses may result in a fatal trap if the authorizing capability does grant the required permissions or the access is out of bounds.
No other exception paths are added: in particular, capability manipulations do not trap, but may clear the tag on the result capability if the operation is not permitted.
